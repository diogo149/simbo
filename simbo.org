* Notes
area: A/B testing
name of technique: A/Z testing
** problem:
-allows for testing only one variable at a time
-people trying to strive for statistical significance for no reason (why 5%???)
-tests are sensitive to when they are tested (e.g. shopping website pre-christmas)
-static exploitation-exploration trade-off (why waste fixed % of traffic on a worse feature)
-developers are trying to solve an optimization problem with a technique that is not good for finding optimal solutions
** symptoms:
-slow changes
-stopping testing early (so you can test something else)
-might have to wait in line for a very critical feature
-manually scheduling tests, and being subject to human  bias on importance/ordering
-exponential number of tests to determine feature interaction
-if you take a greedy approach (eliminating features when they perform poorly), potentially missing out on a completely different route
-slowing down development if experiments are expensive
** solution:
-can essentially ignore the features that are useless
-can test as many variables at the same time, the moment they are available
-can test a feature for as long as you want
-dynamic exploitation-exploration trade-off (slowly, but surely creep towards 0%)
-personalize your testing based on user information (be able to take in some user data and use that to predict the best settings to use)
** technical details:
-can use sequential model based optimzation for higher dimensional
-use some sort of imputation to deal with missing data
-can start off super simple, use built-in libraries for SMBO, and essentially a wrapper around mongo
-you can think of existing A/B testing as grid search in a way; it can work for low dimensionalities but completely breaks down for higher ones which leads to a greedy search
-visualization tool
 -e.g. filters on user demographics and most recent choices for certain variables
-ideally we want online models only so we dont have to retrain for every data point
* Future
-more distributions
-include personalization
-use online models
-store in mongo
-route for feature importances
-sample from local points as well
-fine tune expected improvement formula for our needs
* TODO
-use real db (mongo)
-use online algorithm
 -neural net for low dimensionality, linear model for high?
 -possibly extreme learning machines
-fix demo to be for minimization
-fix objective function to take any values
 -negative values break log
 -make it optimize relative improvement
